<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!--
  The FreeBSD Documentation Project
  The FreeBSD Brazilian Portuguese Documentation Project

  Original revision: r39649

  $FreeBSD$
-->

<chapter id="ports">
  <title>Instalação de Softwares: Pacotes e Ports</title>

  <sect1 id="ports-synopsis">
    <title>Sinopse</title>

    <indexterm><primary>ports</primary></indexterm>
    <indexterm><primary>packages</primary></indexterm>
    <para>O &os; vem com uma rica coleção de ferramentas que fazem 
	parte do sistema base. No entanto, há muito o que se fazer antes 
	de iniciar a instalação de uma aplicação de terceiros para 
	deixa-la funcionando corretamente. O &os; oferece duas tecnologias 
	complementares para a instalação de softwares de terceiros
	em seu sistema: a Coleção de Ports (para realizar instalações a 
	partir dos códigos fonte) e a Coleção de Pacotes (para a instalação 
	de binários pré-compilados). Qualquer método pode ser usado para 
	instalar a mais recente versão de seus aplicativos favoritos através 
	de uma mídia local ou através da rede.</para>

    <para>Depois de ler este capítulo, você saberá:</para>

    <itemizedlist>
      <listitem>
	<para>Como instalar softwares de terceiros usando os pacotes binários.</para>
      </listitem>
      <listitem>
	<para>Como compilar e instalar softwares de terceiros usando a 
	Coleção de Ports.</para>
      </listitem>
      <listitem>
	<para>Como remover pacotes ou ports instalados anteriormente.</para>
      </listitem>
      <listitem>
	<para>Como sobrescrever valores e configurações padrões utilizadas pela 
	Coleção de Ports.</para>
      </listitem>
      <listitem>
	<para>Como localizar o pacote adequado para ser instalado.</para>
      </listitem>
      <listitem>
	<para>Como atualizar seus softwares instalados.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-overview">
    <title>Visão da Instalação de Software</title>

    <para>Se você já usou um sistema &unix; antes, você já sabe que 
	o procedimento típico para a instalação de softwares de 
	terceiros assemelha-se com o seguinte procedimento: </para>

    <procedure>
      <step>
	<para>Obtenha o software, que pode ser distribuído em
	  formato de código fonte ou como um binário.</para>
      </step>

      <step>
	<para>Descompacte o software de seu formato de distribuição
	  (tipicamente um tarball comprimido com &man.compress.1;,
	  &man.gzip.1;., ou &man.bzip2.1;)</para>
      </step>

      <step>
	<para>Localize a documentação (talvez um arquivo chamado 
	  <filename>INSTALL</filename> ou <filename>README</filename>, 
	  ou alguns arquivos presentes em subdiretórios como 
	  <filename>doc/</filename>) e leia sobre como instalar o 
	  software.</para>
      </step>

      <step>
	<para>Se o software foi distribuído em formato de código fonte, 
	  compile-o. Isso pode envolver a edição de um 
	  <filename>Makefile</filename>, a execução de um script 
	  <command>configure</command> e outros passos adicionais.</para>
      </step>

      <step>
	<para>Teste e instale o software.</para>
      </step>
    </procedure>

    <para>E isso é assim só se tudo correr bem. Se você está tentando 
     realizar a instalação de um pacote de software que não foi 
     deliberadamente portado para &os;, você pode até ter de editar o 
     código fonte para fazer com que ele funcione corretamente.</para>

    <para>Se você quiser, você pode continuar a instalar o software 
      de maneira <quote>tradicional</quote>. Entretanto, o &os; 
      disponibiliza duas tecnologias que podem lhe fazer economizar 
      muito tempo e esforço: pacotes e ports. 
      Até o presente momento, cerca de &os.numports; aplicativos de 
      terceiros foram disponibilizados desta maneira para &os;.</para>

    <para>Para qualquer aplicação dada, o pacote para &os; é constituído de
      um único arquivo que você deve obter para efetuar a instalação. O pacote 
      contém cópias pré-compiladas de todos os comandos para a aplicação, 
      bem como arquivos de configuração ou documentação. Um pacote 
      desses pode ser manipulado com comandos como 
      &man.pkg.add.1;, &man.pkg.delete.1;, &man.pkg.info.1; e assim por 
      diante. A instalação de uma nova aplicação pode ser realizada com 
      um único comando.</para>

    <para>Um port para &os; é uma coleção de arquivos designados a 
      automatizar o processo de compilação e instalação de uma 
      aplicação a partir do código fonte.</para>

    <para>Lembre-se de que há uma série de passos que você normalmente 
      deve realizar se você compilou e instalou um programa manualmente 
      (obtenção do código, descompactação, aplicação de patches, 
      compilação e instalação). Os arquivos que formam um port já contém 
      todas as informações necessárias para permitir ao sistema fazer 
      tudo isso por você. Você executa um conjunto bem simples de 
      comandos e o código-fonte do aplicativo é automaticamente obtido, 
      descompactado, recebe patches, é compilado e instalado para você.</para>

    <para>De fato, o sistema de ports pode, também, ser utilizados 
      para gerar os pacotes que, mais tarde, poderão ser manipulados 
      com o <command>pkg_add</command> e com um outro comando para 
      gestão de pacotes que será introduzido em breve.</para>

    <para>Ambos, pacotes e ports, compreendem e resolvem necessidade de 
      <emphasis>dependências</emphasis>. Suponha que você deseja 
      instalar uma aplicação que depende de uma biblioteca específica 
      que deveria ser instalada antes. Tanto a aplicação quanto a 
      biblioteca estão disponíveis em forma de pacotes e ports no &os;. 
      Se você usar o <command>pkg_add</command> ou fizer uso da 
      Coleção de Ports para instalar o aplicativo, ambos irão lhe informar 
      que a biblioteca necessária não está instalada e, antes de instalar 
      a aplicação solicitada, irão instalar a biblioteca para você automaticamente.</para>

    <para>Dado que as duas tecnologias são muito similares, você pode 
      estar se perguntando por que o &os; se preocupa com ambas. Tanto 
      os pacotes quanto os ports têm seus próprios benefícios, e qual 
      você irá utilizar dependerá da sua preferência pessoal.</para>

    <itemizedlist>
      <title>Benfícios do Pacote</title>

      <listitem>
	<para>Um pacote tarball comprimido é tipicamente menor do que um 
	  tarball compactado contendo o código fonte da aplicação.</para>
      </listitem>

      <listitem>
	<para>O uso de pacotes não requer nenhuma compilação adicional. Para
	  aplicações de grande porte, tais como
	  <application>Mozilla</application>,
	  <application>KDE</application> ou
	  <application>GNOME</application> isso pode ser importante,
	  especialmente se você estiver em um sistema lento.</para>
      </listitem>

      <listitem>
	<para>O uso de pacotes não requer nenhum conhecimento do processo
	  envolvido na compilação de softwares no &os;.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Benefícios do Port</title>

      <listitem>
	<para>Pacotes são compilados normalmente com opções conservadoras
	  porque eles têm que ser executados no maior número de sistemas possíveis. 
	  A instalação de um port lhe possibilita ajustar opções de compilação para 
	  (por exemplo) geração de código específico para ser executado num 
	  processador Pentium4 ou Athlon.</para>
      </listitem>

      <listitem>
	<para>Opções de compilação (compile-time) são relativas ao que os pacotes
	  podem e não podem fazer. Por exemplo, o <application>Apache</application> 
	  pode ser configurado com uma ampla variedade de diferentes opções 
	  embutidas. Ao compilá-lo a partir do port você não tem que aceitar as 
	  opções padrão e pode definir suas próprias customizações.</para>

	<para>Em alguns casos, vários pacotes podem existir para a mesma aplicação, 
	  especificando, assim, diferentes customizações. Por exemplo, o 
	  <application>Ghostscript</application> está disponível em forma de pacote 
	  como <filename>ghostscript</filename> e como <filename>ghostscript-nox11</filename>, 
	  para lhe atender se você tem ou não um servidor X11 instalado. Este tipo 
	  de ajuste fino é possível com pacotes, mas torna-se inviável se o aplicativo 
	  tem mais de uma ou duas opções de compilação.</para>
      </listitem>

      <listitem>
	<para>As condições de licenciamento de distribuição de alguns software 
	  proíbem sua distribuição em formato binãrio. Eles devem ser 
	  distribuídos apenas em formato de código fonte.</para>
      </listitem>

      <listitem>
	<para>Algumas pessoas não confiam em distribuições binárias. Pelo menos
	  com o código fonte, você pode (em teoria) lê-lo e
	  procurar por potenciais problemas.</para>
      </listitem>

      <listitem>
	<para>Se você tem patches a serem aplicados, será necessário o código 
	  fonte para aplicá-los.</para>
      </listitem>

      <listitem>
	<para>Algumas pessoas gostam de ter o código fonte para que possam lê-lo
	  se ficarem entediadas, implementar alguma modificação, reutilizar 
	  (caso a licença permita, é claro) e assim por diante.</para>
      </listitem>
    </itemizedlist>

    <para>Para manter-se altualizado em relação aos ports, assine as listas
      &a.ports; e &a.ports-bugs;.</para>

    <warning>
      <para>Antes de instalar qualquer aplicativo, você deve verificar <ulink 
        url="http://vuxml.freebsd.org/"></ulink> para considerar questões de segurança
        relacionadas a aplicação.</para>

      <para>Você também pode instalar o 
        <filename role="package">ports-mgmt/portaudit</filename>, que irá verificar 
        automaticamente a existência de vulnerabilidade em todos os aplicativos 
        instalados; uma verificação também será realizada antes de qualquer nova 
        compilação de um port. Além disso, você pode usar o comando 
        <command>portaudit -F -a</command> depois de ter instalado um pacote.</para>
    </warning>

    <para>O restante deste capítulo irá explicar como usar pacotes e 
      ports para instalar e gerenciar o softwares de terceiros no &os;.</para>
  </sect1>

  <sect1 id="ports-finding-applications">
    <title>Localizando o Software</title>

    <para>Before you can install any applications you need to know what you
      want, and what the application is called.</para>

    <para>FreeBSD's list of available applications is growing all the
      time.  Fortunately, there are a number of ways to find what you
      want:</para>

    <itemizedlist>
      <listitem>
	<para>The FreeBSD web site maintains an up-to-date searchable
	  list of all the available applications, at <ulink
	  url="&url.base;/ports/index.html">http://www.FreeBSD.org/ports/</ulink>.
	  The ports are divided into categories, and you may either
	  search for an application by name (if you know it), or see
	  all the applications available in a category.</para>
      </listitem>

      <listitem>
	<indexterm><primary>FreshPorts</primary></indexterm>

	<para>Dan Langille maintains FreshPorts, at <ulink
	  url="http://www.FreshPorts.org/"></ulink>.  FreshPorts
	  tracks changes to the applications in the ports tree as they
	  happen, allows you to <quote>watch</quote> one or more
	  ports, and can send you email when they are updated.</para>
      </listitem>

      <listitem>
      <indexterm><primary>Freecode</primary></indexterm>

	<para>If you do not know the name of the application you want,
	  try using a site like Freecode (<ulink
	  url="http://www.freecode.com/"></ulink>) to find an
	  application, then check back at the FreeBSD site to see if
	  the application has been ported yet.</para>
      </listitem>

      <listitem>
	<para>If you know the exact name of the port, but just need to
        find out which category it is in, you can use the
        &man.whereis.1; command.
	Simply type <command>whereis
        <replaceable>file</replaceable></command>, where
        <replaceable>file</replaceable> is the program you want to
        install.  If it is found on your system, you will be told
        where it is, as follows:</para>

      <screen>&prompt.root; <userinput>whereis lsof</userinput>
lsof: /usr/ports/sysutils/lsof</screen>

      <para>This tells us that <command>lsof</command> (a system
	utility) can be found in the
	<filename>/usr/ports/sysutils/lsof</filename>
	directory.</para></listitem>

      <listitem>
	<para>Additionally, you can use a simple &man.echo.1; statement
	  to find where a port exists in the ports tree.  For
	  example:</para>

	<screen>&prompt.root; <userinput>echo /usr/ports/*/*lsof*</userinput>
/usr/ports/sysutils/lsof</screen>

	<para>Note that this will return any matched files downloaded into the
	  <filename class="directory">/usr/ports/distfiles</filename>
	  directory.</para>
      </listitem>

      <listitem>
	<para>Yet another way to find a particular port is by using the
        Ports Collection's built-in search mechanism.  To use the
        search feature, you will need to be in the
        <filename>/usr/ports</filename> directory.  Once in that
        directory, run <command>make <maketarget>search</maketarget>
        name=<replaceable>program-name</replaceable></command> where
        <replaceable>program-name</replaceable> is the name of the
        program you want to find.  For example, if you were looking
        for <command>lsof</command>:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search name=lsof</userinput>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps: </screen>

      <para>The part of the output you want to pay particular
        attention to is the <quote>Path:</quote> line, since that
        tells you where to find the port.  The other information
        provided is not needed in order to install the port, so it
        will not be covered here.</para>

      <para>For more in-depth searching you can also use <command>make
       <maketarget>search</maketarget> key=<replaceable>string</replaceable></command>
       where <replaceable>string</replaceable> is some text to search for.
       This searches port names, comments, descriptions and
       dependencies and can be used to find ports which relate to a
       particular subject if you do not know the name of the program
       you are looking for.</para>

      <para>In both of these cases, the search string is case-insensitive.
       Searching for <quote>LSOF</quote> will yield the same results as
       searching for <quote>lsof</quote>.</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 id="packages-using">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    <!-- 30 Mar 2001 -->
    </sect1info>

    <title>Utilizando o Sistema de Pacotes</title>

    <para>There are several different tools used to manage packages on
      FreeBSD:</para>

    <itemizedlist>
      <listitem><para>The <command>sysinstall</command> utility can be invoked on a
        running system to install, delete, and list available and
        installed packages. For more information, see <xref
        linkend="packages"/>.</para></listitem>
      <listitem><para>The package management command line tools, which are
        the subject of the rest of this section.</para></listitem>
    </itemizedlist>

    <sect2>
      <title>Instalando um Pacote</title>
      <indexterm>
        <primary>packages</primary>
        <secondary>installing</secondary>
      </indexterm>

      <indexterm>
        <primary><command>pkg_add</command></primary>
      </indexterm>
      <para>Você pode usar o utilitário &man.pkg.add.1; para 
	instalar um pacote do &os; a partir de um arquivo local 
	ou através da rede.</para>

      <example>
        <title>Obtendo e Instalando o Pacote Manualmente</title>

        <screen>&prompt.root; <userinput>ftp -a <replaceable>ftp2.FreeBSD.org</replaceable></userinput>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server (Version 6.00LS) ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is in Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
<prompt>ftp></prompt> <userinput>cd /pub/FreeBSD/ports/packages/sysutils/</userinput>
250 CWD command successful.
<prompt>ftp></prompt> <userinput>get lsof-4.56.4.tgz</userinput>
local: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT command successful.
150 Opening BINARY mode data connection for 'lsof-4.56.4.tgz' (92375 bytes).
100% |**************************************************| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received in 5.60 seconds (16.11 KB/s)
<prompt>ftp></prompt> <userinput>exit</userinput>
&prompt.root; <userinput>pkg_add <replaceable>lsof-4.56.4.tgz</replaceable></userinput></screen>
      </example>

      <para>Se você não tem uma fonte de pacotes locais (como um
         conjunto de CDs ou DVDs do &os;), então provavelmente será 
	 mais fácil usar a opção <option>-r</option> do 
	 &man.pkg.add.1;. Assim, ele irá fazer automaticamente o 
	 download do aplicativo solicitado, segundo sua release, e 
	 irá instalar para você.</para>

      <indexterm>
        <primary><command>pkg_add</command></primary></indexterm>
      <screen>&prompt.root; <userinput>pkg_add -r <replaceable>lsof</replaceable></userinput></screen>

      <para>O exemplo acima deve baixar o pacote correto e
	adicioná-lo sem qualquer intervenção do usuário.
	Se você deseja especificar um servidor espelho alternativo, 
	ao invés do servidor principal, você tem que definir o 
	valor da variável de ambiente <envar>PACKAGESITE</envar>. 
	Essa variável substitui a configuraçãi padrão. O &man.pkg.add.1; 
	faz uso do &man.fetch.3; ao baixar os arquivos, que, por sua vez, 
	faz uso de várias outras variáveis de ambiente, incluindo 
	<envar>FTP_PASSIVE_MODE</envar>, <envar>FTP_PROXY</envar> e <envar>FTP_PASSWORD</envar>. 
	Você pode precisar configurar uma ou mais dessas variáveis 
	se você estiver atrás de um firewall, ou se houver 
	necessidade de utilizar um proxy FTP/HTTP. Consulte a página 
	de manual &man.fetch.3; para ver a lista completa de 
	variáveis utilizadas. Note ainda que, no exemplo acima, 
	<literal>lsof</literal> é usado em vez de <literal>lsof-4.56.4</literal>. 
	Quando a busca remota é utilizada, o número da versão do 
	pacote deve ser removido. O &man.pkg.add.1; vai buscar 
	automaticamente a último versão do aplicativo.</para>

      <note>
	<para>O &man.pkg.add.1; vai baixar a última versão da 
	  aplicação se você estiver usando &os.current; ou &os.stable;. 
	  Se você estiver a usar uma versão RELEASE ele vai pegar a 
	  versão do pacote que foi compilado para a versão atual da 
	  RELEASE após seu lançamento. É possível alterar esse 
	  comportamento substituindo a variável de ambiente 
	  <envar>PACKAGESITE</envar>. Por exemplo, se você estiver 
	  com um &os; 8,1-RELEASE, o &man.pkg.add.1; vai tentar buscar 
	  pacotes em <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest</literal>. 
	  Se você quiser alterar esse destino, basta redefinir o 
	  endereço de consulta através da variável <envar>PACKAGESITE</envar> 
	  para, por exemplo, 
	  <literal>ftp://ftp.br.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest</literal>.
	</para>
      </note>

      <para>Pacotes são distribuídos em formatos 
	  <filename>.tgz</filename> e <filename>.tbz</filename>. 
	  Você pode encontrá-los em <ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages"></ulink> 
	  ou num CD-ROM do &os;. Cada um dos 4 (quatro) CDs do 
	  conjunto de CDs (PowerPak e etc.) contém pacotes no diretório 
	  <filename>/packages</filename>. O layout é semelhante a 
	  árvore da Coleção de Ports presente, por padrão, em 
	  <filename>/usr/ports</filename>. Cada categoria tem seu 
	  próprio diretório e cada pacote pode ser encontrado 
	  dentro do diretório <filename>All</filename>.
       </para>

      <para>A estrutura de diretórios do sistema de pacotes 
	corresponde ao layout adotado pela Coleção de Ports. 
	Assim, ambas as estruturas podem se relacionar a fim de 
	formar um sistema de pacotes/ports completo.</para>

    </sect2>

    <sect2>
      <title>Gerenciando Pacotes</title>

      <indexterm>
        <primary>packages</primary>
        <secondary>managing</secondary>
      </indexterm>
      <para>O &man.pkg.info.1; é um utilitário que lista e descreve
        os vários pacotes instalado.
      </para>

      <indexterm>
        <primary><command>pkg_info</command></primary>
      </indexterm>
      <screen>&prompt.root; <userinput>pkg_info</userinput>
cvsup-16.1          A general network file distribution system optimized for CV
docbook-1.2         Meta-port for the different versions of the DocBook DTD
...</screen>

      <para>O &man.pkg.version.1; é um utilitário que te exibe um resume das
         versões de todos os pacotes instalados. Ele compara a versão atual do pacote
         com a versão presente na Coleção de Ports presente no sistema.
       </para>

      <indexterm>
        <primary><command>pkg_version</command></primary>
      </indexterm>
        <screen>&prompt.root; <userinput>pkg_version</userinput>
cvsup                       =
docbook                     =
...</screen>

      <para>Os símbolos na segunda coluna indicam a <quote>idade relativa</quote>
        entre a versão instalada e a versão disponível na
        Coleção de Ports local do sistema.</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
            <row>
              <entry>Símbolo</entry>
              <entry>Significado</entry>
            </row>
          </thead>

 	  <tbody>
  	    <row>
	    <entry>=</entry> <entry>A versão do
		pacote instalado corresponde a versão presente na
		Coleção de Ports atual do sistema.</entry>
  	    </row>

        <row><entry>&lt;</entry>
	<entry>A versão do pacote instalado é inferior a versão 
	  presente na Coleção de Ports atual do sistema.</entry>
	</row>

        <row><entry>&gt;</entry><entry>A versão do
	  pacote instalado é mais recente que a versão presente na
	  Coleção de Ports atual do sistema (aparentemente sua 
	  Coleção de Ports está desatualizada).</entry></row>

        <row><entry>?</entry><entry>A versão do pacote não pode ser 
	  licalizada no índice da Coleção de Ports. Isso pode acontecer, 
	  por exemplo, se um port instalado foi removido ou 
	  renomeado na Coleção de Ports.</entry></row>

        <row><entry>*</entry><entry>Existem diferentes (várias) versões 
	  do pacote.</entry></row>

        <row><entry>!</entry><entry>O pacote existe, mas, por alguma 
	  razão desconhecida, o <command>pkg_version</command> foi 
	  incapaz de comparar a versão instalada e a versão 
	  presente no índice.</entry></row>

	</tbody>
	</tgroup>
    </informaltable>
    </sect2>

    <sect2>
      <title>Removendo um Pacote</title>
      <indexterm>
        <primary><command>pkg_delete</command></primary>
      </indexterm>
      <indexterm>
        <primary>packages</primary>
        <secondary>deleting</secondary>
      </indexterm>
      <para>Para remover uma versão de um pacote previamente instalado, 
	utilize a ferramenta &man.pkg.delete.1;.
      </para>

      <screen>&prompt.root; <userinput>pkg_delete <replaceable>xchat-1.7.1</replaceable></userinput></screen>

      <para>Repare que o &man.pkg.delete.1; requer que seja informado 
	o nome e a versão do pacote. O comando acima não funcionaria se 
	apenas <replaceable>xchat</replaceable> tivesse sido utilizado como 
	nome do pacote a ser desinstalado. É necessário informar 
	<replaceable>xchat-1.7.1</replaceable>. No entanto, é fácil de 
	usar o &man.pkg.version.1; para encontrar a versão do pacote instalado. 
	Você poderia, ainda, simplesmente usar um curinga:</para>

      <screen>&prompt.root; <userinput>pkg_delete <replaceable>xchat\*</replaceable></userinput></screen>

      <para>Nesse caso, todos os pacotes que tivessem seu nome 
	iniciando com <literal>xchat</literal> seriam deletados.</para>
    </sect2>

    <sect2>
      <title>Miscelânea</title>

      <para>Todas as informações ligadas aos pacotes são armazenadas
	no diretório <filename>/var/db/pkg</filename>. A lista e 
	descrição de todos os pacotes instalados no sistema podem ser 
	encontradas em arquivos presentes nesse mesmo diretório.</para>
    </sect2>
  </sect1>

  <sect1 id="ports-using">
    <title>Utilizando a Coleção de Ports</title>

    <para>The following sections provide basic instructions on using the
      Ports Collection to install or remove programs from your
      system.  The detailed description of available <command>make</command>
      targets and environment variables is available in &man.ports.7;.</para>

    <warning>
      <para>As of late 2012, the &os; Ports Project is in the
	process of migrating revision control systems from CVS to
	Subversion.  As a result, these instructions are in a state of
	change.  The preferred mechanism for general ports use is
	<application>Portsnap</application>.  Users requiring local
	customization of ports (that is, maintaining additional local
	patches) will probably prefer to use Subversion directly.  The
	<application>CVSup</application> service is being phased out
	as of February 28, 2013, and further use is
	discouraged.</para>
    </warning>

    <sect2 id="ports-tree">
      <title>Obtendo a Coleção de Ports</title>

      <para>The Ports Collection is a set of
	<filename>Makefiles</filename>, patches, and description files
	stored in <filename>/usr/ports</filename>.  This set of files
	is used for building and installing applications on &os;.  The
	instructions below show several methods of obtaining the Ports
	Collection if it was not installed during initial &os;
	setup.</para>

      <procedure>
	<title>Utilizando o Portsnap</title>

	<para><application>Portsnap</application> is a fast and
	  user-friendly tool for retrieving the Ports Collection, the
	  preferred choice for most users.  See
	  <link linkend="updating-upgrading-portsnap">Using
	    Portsnap</link> for a detailed description of
	  <application>Portsnap</application>.</para>

	<step>
	  <para>Download a compressed snapshot of the Ports Collection
	    into <filename
	      class="directory">/var/db/portsnap</filename>.</para>

	  <screen>&prompt.root; <userinput>portsnap fetch</userinput></screen>
	</step>

	<step>
	  <para>When running <application>Portsnap</application>
	    for the first time, extract the snapshot into
	    <filename class="directory">/usr/ports</filename>:</para>

	  <screen>&prompt.root; <userinput>portsnap extract</userinput></screen>

	  <para>After the first use of
	    <application>Portsnap</application> has been completed as
	    shown above,
	    <filename class="directory">/usr/ports</filename> can be
	    updated with:</para>

	  <screen>&prompt.root; <userinput>portsnap update</userinput></screen>
	</step>
      </procedure>

      <procedure>
	<title>Utilizando o Subversion</title>

	<para>If more control over the ports tree is needed (for
	  example, for maintaining local changes)
	  <application>Subversion</application> can be used to
	  obtain the Ports Collection.  Refer to <ulink
	    url="&url.articles.committers-guide;/subversion-primer.html">the
	    Subversion Primer</ulink> for a detailed description of
	  <application>Subversion</application>.</para>

	<step>
	  <para><application>Subversion</application> must be
	    installed before it can be used to check out the ports
	    tree.  If a copy of the ports tree is already present,
	    install <application>Subversion</application> like
	    this:</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/devel/subversion</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	  <para>If the ports tree is not available,
	    <application>Subversion</application> can be installed as
	    a package:</para>

	  <screen>&prompt.root; <userinput>pkg_add -r subversion</userinput></screen>

	  <para>If <application>pkgng</application> is being used to
	    manage packages, <application>Subversion</application> can 
	    be installed with it instead:</para>

	  <screen>&prompt.root; <userinput>pkg install subversion</userinput></screen>
	</step>

	<step>
	  <para>Check out a copy of the ports tree.  Use a specific
	    <ulink
	      url="&url.books.handbook;/mirrors-svn.html">Subversion
	      mirror</ulink> close to your geographic location instead
	    of <replaceable>svn.FreeBSD.org</replaceable> in the
	    command below for better performance.  Committers should
	    read the <ulink
	      url="&url.articles.committers-guide;/subversion-primer.html">Subversion
	      Primer</ulink> first to be sure the correct protocol is
	    chosen.</para>

	  <screen>&prompt.root; <userinput>svn checkout svn://<replaceable>svn.FreeBSD.org</replaceable>/ports/head /usr/ports</userinput></screen>
	</step>

	<step>
	  <para>To update
	    <filename class="directory">/usr/ports</filename> after
	    the initial <application>Subversion</application>
	    checkout:</para>

	  <screen>&prompt.root; <userinput>svn update /usr/ports</userinput></screen>
	</step>
      </procedure>

      <procedure>
	<title>Utilizando o CVSup</title>

	<warning>
	  <para>The CVSup method of retrieving and synchronizing the
	    Ports Collection is being deprecated as part of a
	    migration to Subversion.  While it remains supported, the
	    service will be discontinued as of February 28,
	    2013.</para>
	</warning>

	<para>This is a quick method for getting and keeping your copy of the
	  Ports Collection up to date using <application>CVSup</application>
	  protocol.  If you want to learn more about
	  <application>CVSup</application>, see <link
	    linkend="cvsup">Using CVSup</link>.</para>

	<note>
	  <para>The implementation of <application>CVSup</application> protocol
	    included with the &os; system is called
	    <application>csup</application>.</para>
	</note>

	<para>Make sure <filename class="directory">/usr/ports</filename>
	  is empty before you run <application>csup</application> for
	  the first time!  If you already have the Ports Collection present,
	  obtained from another source, <application>csup</application>
	  will not prune removed patch files.</para>

	<step>
	  <para>Run <command>csup</command>:</para>

	  <screen>&prompt.root; <userinput>csup -L 2 -h <replaceable>cvsup.FreeBSD.org</replaceable> /usr/share/examples/cvsup/ports-supfile</userinput></screen>

	  <para>Change
	    <replaceable>cvsup.FreeBSD.org</replaceable> to a
	    <application>CVSup</application> server near you.  See
	    <link linkend="cvsup-mirrors">CVSup Mirrors</link> (<xref
	    linkend="cvsup-mirrors"/>) for a complete listing of mirror
	    sites.</para>

	  <note>
	    <para>One may want to use his own
	      <filename>ports-supfile</filename>, for example to avoid
	      the need of passing the <application>CVSup</application>
	      server on the command line.</para>

	    <procedure>
	      <step>
		<para>In this case, as <username>root</username>, copy
		  <filename>/usr/share/examples/cvsup/ports-supfile</filename>
		  to a new location, such as
		  <filename>/root</filename> or your home
		  directory.</para>
	      </step>

	      <step>
		<para>Edit <filename>ports-supfile</filename>.</para>
	      </step>

	      <step>
		<para>Change
		  <replaceable>CHANGE_THIS.FreeBSD.org</replaceable>
		  to a <application>CVSup</application> server near
		  you.  See <link linkend="cvsup-mirrors">CVSup
		  Mirrors</link> (<xref linkend="cvsup-mirrors"/>) for
		  a complete listing of mirror sites.</para>
	      </step>

	      <step>
		<para>And now to run <command>csup</command>, use the
		  following:</para>

		<screen>&prompt.root; <userinput>csup -L 2 <replaceable>/root/ports-supfile</replaceable></userinput></screen>
	      </step>
	    </procedure>
	  </note>
	</step>

	<step>
	  <para>Running the &man.csup.1; command later will download and apply
	    all the recent changes to your Ports Collection, except
	    actually rebuilding the ports for your own system.</para>
	</step>
      </procedure>

      <procedure>
	<title>Utilizando o Sysinstall</title>

	<para>This method involves using <application>sysinstall</application>
	  to install the Ports Collection from the installation media.  Note
	  that the old copy of Ports Collection from the date of the release
	  will be installed.  If you have Internet access, you should always
	  use one of the methods mentioned above.</para>

	<step>
	  <para>As <username>root</username>, run
	    <command>sysinstall</command> as shown below:</para>

	  <screen>&prompt.root; <userinput>sysinstall</userinput></screen>
	</step>

	<step>
	  <para>Scroll down and select <guimenuitem>Configure</guimenuitem>,
	    press <keycap>Enter</keycap>.</para>
	</step>

	<step>
	  <para>Scroll down and select
	    <guimenuitem>Distributions</guimenuitem>, press
	    <keycap>Enter</keycap>.</para>
	</step>

	<step>
	  <para>Scroll down to <guimenuitem>ports</guimenuitem>, press
	    <keycap>Space</keycap>.</para>
	</step>

	<step>
	  <para>Scroll up to <guimenuitem>Exit</guimenuitem>, press
	    <keycap>Enter</keycap>.</para>
	</step>

	<step>
	  <para>Select your desired installation media, such as CDROM,
	    FTP, and so on.</para>
	</step>

	<step>
	  <para>Scroll up to <guimenuitem>Exit</guimenuitem> and press
	    <keycap>Enter</keycap>.</para>
	</step>

	<step>
	  <para>Press <keycap>X</keycap> to exit
	    <application>sysinstall</application>.</para>
	</step>
      </procedure>
    </sect2>

    <sect2 id="ports-skeleton">
      <title>Instalando Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>installing</secondary>
      </indexterm>
      <para>The first thing that should be explained when it comes to
        the Ports Collection is what is actually meant by a
        <quote>skeleton</quote>.  In a nutshell, a port skeleton is a
        minimal set of files that tell your FreeBSD system how to
        cleanly compile and install a program.  Each port skeleton
        includes:</para>

      <itemizedlist>
	<listitem>
	  <para>A <filename>Makefile</filename>.  The
	    <filename>Makefile</filename> contains various statements
	    that specify how the application should be compiled and
	    where it should be installed on your system.</para>
	</listitem>

	<listitem>
	  <para>A <filename>distinfo</filename> file.  This file
	    contains information about the files that must be
	    downloaded to build the port, and their checksums
	    (using &man.sha256.1;), to
	    verify that files have not been corrupted during the
	    download.</para>
	</listitem>

	<listitem>
	  <para>A <filename>files</filename> directory.  This
	    directory contains patches to make the program compile and
	    install on your FreeBSD system.  Patches are basically
	    small files that specify changes to particular files.
	    They are in plain text format, and basically say
	    <quote>Remove line 10</quote> or <quote>Change line 26 to
	    this ...</quote>.  Patches are also known as
	    <quote>diffs</quote> because they are generated by the
	    &man.diff.1; program.</para>

	  <para>This directory may also contain other files used to build
	    the port.</para>
	</listitem>

	<listitem>
	  <para>A <filename>pkg-descr</filename> file.  This is a more
	    detailed, often multiple-line, description of the program.</para>
	</listitem>

	<listitem>
	  <para>A <filename>pkg-plist</filename> file.  This is a list
	    of all the files that will be installed by the port.  It
	    also tells the ports system what files to remove upon
	    deinstallation.</para>
	</listitem>
      </itemizedlist>

      <para>Some ports have other files, such as
        <filename>pkg-message</filename>.  The ports system uses these
        files to handle special situations.  If you want more details
        on these files, and on ports in general, check out the <ulink
        url="&url.books.porters-handbook;/index.html">FreeBSD Porter's
        Handbook</ulink>.</para>

      <para>The port includes instructions on how to build source
        code, but does not include the actual source code.  You can
        get the source code from a CD-ROM or from the Internet.
        Source code is distributed in whatever manner the software
        author desires.  Frequently this is a tarred and gzipped file,
        but it might be compressed with some other tool or even
        uncompressed.  The program source code, whatever form it comes
        in, is called a <quote>distfile</quote>.  The two methods for
        installing a &os; port are described below.</para>

      <note>
        <para>You must be logged in as <username>root</username> to
          install ports.</para>
      </note>

      <warning>
	<para>Before installing any port, you should be sure to have
	  an up-to-date Ports Collection and you should check <ulink
	  url="http://vuxml.freebsd.org/"></ulink> for security issues
	  related to your port.</para>

	<para>A security vulnerabilities check can be automatically
	  done by <application>portaudit</application> before any new
	  application installation.  This tool can be found in the
	  Ports Collection (<filename
	  role="package">ports-mgmt/portaudit</filename>).  Consider
	  running <command>portaudit -F</command> before installing a
	  new port, to fetch the current vulnerabilities database.  A
	  security audit and an update of the database will be
	  performed during the daily security system check.  For more
	  information read the &man.portaudit.1; and &man.periodic.8;
	  manual pages.</para>
      </warning>

      <para>The Ports Collection makes an assumption that you have a working
	Internet connection.  If you do not, you will need to put a copy of the
	distfile into <filename>/usr/ports/distfiles</filename>
	manually.</para>

	<para>To begin, change to the directory for the port you want to
	  install:</para>

        <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput></screen>

        <para>Once inside the <filename>lsof</filename> directory, you
	  will see the port skeleton.  The next step is to compile, or
	  <quote>build</quote>, the port.  This is done by simply
	  typing <command>make</command> at the prompt.  Once you have
	  done so, you should see something like this:</para>

        <screen>&prompt.root; <userinput>make</userinput>
&gt;&gt; lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
&prompt.root;</screen>

        <para>Notice that once the compile is complete you are
	  returned to your prompt.  The next step is to install the
	  port.  In order to install it, you simply need to tack one word
	  onto the <command>make</command> command, and that word is
	  <maketarget>install</maketarget>:</para>

        <screen>&prompt.root; <userinput>make install</userinput>
===&gt;  Installing for lsof-4.57
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.57
===&gt;   Registering installation for lsof-4.57
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
&prompt.root;</screen>

        <para>Once you are returned to your prompt, you should be able to
          run the application you just installed.  Since
	  <command>lsof</command> is a
	  program that runs with increased privileges, a security
	  warning is shown.  During the building and installation of
	  ports, you should take heed of any other warnings that
	  may appear.</para>

	<para>It is a good idea to delete the working subdirectory,
	  which contains all the temporary files used during compilation.
	  Not only does it consume valuable disk space, but it would also
	  cause problems later when upgrading to the newer version of the
	  port.</para>

	<screen>&prompt.root; <userinput>make clean</userinput>
===&gt;  Cleaning for lsof-4.57
&prompt.root;</screen>

        <note>
          <para>You can save two extra steps by just running <command>make
	    <maketarget>install clean</maketarget></command> instead of
	    <command>make</command>,
	    <command>make <maketarget>install</maketarget></command> and
	    <command>make <maketarget>clean</maketarget></command>
	    as three separate steps.</para>
	</note>

	<note>
	  <para>When installing a port, using only <command>make
	      <maketarget>install</maketarget></command> from the
	    beginning means there will potentially be many waiting
	    periods between user interaction as the default behaviour
	    is to prompt the user for options.  When there are many
	    dependencies, this sometimes makes building a single port
	    a huge hassle.  To avoid this, first run <command>make
	      <maketarget>config-recursive</maketarget></command> to
	    do the configuration in one batch.  Then run
	    <command>make <maketarget>install
	      [clean]</maketarget></command> afterwards.</para>
	</note>

	<tip>
	  <para>When using <maketarget>config-recursive</maketarget>,
	    the list of ports to configure are gathered by the
	    <maketarget>all-depends-list</maketarget> &man.make.1;
	    target.  It is often recommended to run <command>make
	      <maketarget>config-recursive</maketarget></command>
	    until all dependent ports options have been defined, and
	    ports options &man.dialog.1; screens no longer
	    appear, to be certain all ports options have been
	    configured as intended.</para>
	</tip>

	<note>
	  <para>Some shells keep a cache of the commands that are
	    available in the directories listed in the
	    <envar>PATH</envar> environment variable, to speed up
	    lookup operations for the executable file of these
	    commands.  If you are using one of these shells, you might
	    have to use the <command>rehash</command> command after
	    installing a port, before the newly installed commands can
	    be used.  This command will work for shells like
	    <command>tcsh</command>.  Use the <command>hash -r</command>
	    command for shells like <command>sh</command>.  Look at the
	    documentation for your shell for more information.</para>
	</note>

	<para>Some third-party DVD-ROM products such as the FreeBSD Toolkit
	  from the <ulink url="http://www.freebsdmall.com/">FreeBSD
	  Mall</ulink> contain distfiles.  They can be used with the Ports
	  Collection.  Mount the DVD-ROM on <filename>/cdrom</filename>.  If
	  you use a different mount point, set <makevar>CD_MOUNTPTS</makevar>
	  make variable.  The needed distfiles will be automatically used
	  if they are present on the disk.</para>

	<note>
	  <para>Please be aware that the licenses of a few ports do
	    not allow for inclusion on the CD-ROM.  This could be
	    because a registration form needs to be filled out before
	    downloading or redistribution is not allowed, or for
	    another reason.  If you wish to install a port not
	    included on the CD-ROM, you will need to be online in
	    order to do so.</para>
	</note>

	<para>The ports system uses &man.fetch.1; to download the
	  files, which honors various environment variables, including
	  <envar>FTP_PASSIVE_MODE</envar>, <envar>FTP_PROXY</envar>,
	  and <envar>FTP_PASSWORD</envar>.  You may need to set one or
	  more of these if you are behind a firewall, or need to use
	  an FTP/HTTP proxy.  See &man.fetch.3; for the complete
	  list.</para>

	<para>For users which cannot be connected all the time, the
	  <command>make <maketarget>fetch</maketarget></command> option is
	  provided.  Just run this command at the top level directory
	  (<filename>/usr/ports</filename>) and the required files
	  will be downloaded for you.  This command will also work in
	  the lower level categories, for example:
	  <filename>/usr/ports/net</filename>.
	  Note that if a port depends on libraries or other ports this will
	  <emphasis>not</emphasis> fetch the distfiles of those ports too.
	  Replace <maketarget>fetch</maketarget> with
	  <maketarget>fetch-recursive</maketarget>
	  if you want to fetch all the dependencies of a port too.</para>

	<note><para>You can build all the ports in a category or as a
	  whole by running <command>make</command> in the top level
	  directory, just like the aforementioned <command>make
	  <maketarget>fetch</maketarget></command> method.  This is
	  dangerous, however, as some ports cannot co-exist.  In other
	  cases, some ports can install two different files with the
	  same filename.</para></note>

	<para>In some rare cases, users may need to acquire the
	  tarballs from a site other than the
	  <makevar>MASTER_SITES</makevar> (the location where files
	  are downloaded from).  You can override the
	  <makevar>MASTER_SITES</makevar> option with the following
	  command:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>

	<para>In this example we change the
	  <makevar>MASTER_SITES</makevar> option to <hostid
	  role="fqdn">ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</hostid>.</para>

	<note><para>Some ports allow (or even require) you to provide
	  build options which can enable/disable parts of the
	  application which are unneeded, certain security options,
	  and other customizations.  A few which come to mind are
	  <filename role="package">www/firefox</filename>, <filename
	  role="package">security/gpgme</filename>, and <filename
	  role="package">mail/sylpheed-claws</filename>.  A message
	  will be displayed when options such as these are
	  available.</para></note>

      <sect3>
        <title>Overriding the Default Ports Directories</title>

	<para>Sometimes it is useful (or mandatory) to use a different
	  working and target directory.  The
	  <makevar>WRKDIRPREFIX</makevar> and <makevar>PREFIX</makevar>
	  variables can override the default directories.  For
	  example:</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=/usr/home/example/ports install</userinput></screen>

	<para>will compile the port in
	    <filename>/usr/home/example/ports</filename> and install
	    everything under <filename>/usr/local</filename>.</para>

	<screen>&prompt.root; <userinput>make PREFIX=/usr/home/example/local install</userinput></screen>

	<para>will compile it in <filename>/usr/ports</filename> and
	  install it in
	  <filename>/usr/home/example/local</filename>.</para>

	<para>And of course,</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=../ports PREFIX=../local install</userinput></screen>

	<para>will combine the two (it is too long to completely write
	  on this page, but it should give you the general
	  idea).</para>

	<para>Alternatively, these variables can also be set as part
	  of your environment.  Read the manual page for your shell
	  for instructions on doing so.</para>
      </sect3>

      <sect3>
	<title>Lidando com o <command>imake</command></title>

	<para>Some ports that use <command>imake</command> (a part of
	  the X Window System) do not work well with
	  <makevar>PREFIX</makevar>, and will insist on installing
	  under <filename>/usr/X11R6</filename>.  Similarly, some Perl
	  ports ignore <makevar>PREFIX</makevar> and install in the
	  Perl tree.  Making these ports respect
	  <makevar>PREFIX</makevar> is a difficult or impossible
	  job.</para>

      </sect3>

      <sect3>
	<title>Reconfigurando Ports</title>

	<para>When building certain ports, you may be presented with a
	  ncurses-based menu from which you can select certain build options.
	  It is not uncommon for users to wish to revisit this menu to add,
	  remove, or change these options after a port has been built.  There
	  are many ways to do this.  One option is to go into the directory
	  containing the port and type <command>make
	  <maketarget>config</maketarget></command>, which will simply present
	  the menu again with the same options selected.  Another option is to
	  use <command>make <maketarget>showconfig</maketarget></command>,
	  which will show you all the configuration options for the port.  Yet
	  another option is to execute <command>make
	  <maketarget>rmconfig</maketarget></command> which will remove all
	  selected options and allow you to start over.  All of these options,
	  and others, are explained in great detail in the manual page for
	  &man.ports.7;.</para>
      </sect3>
    </sect2>

    <sect2 id="ports-removing">
      <title>Removendo Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>removing</secondary>
      </indexterm>
      <para>Now that you know how to install ports, you are probably
        wondering how to remove them, just in case you install one and
	later on decide that you installed the wrong port.
        We will remove our previous example (which was
	<command>lsof</command> for
	those of you not paying attention).  Ports are being removed exactly
	the same as the packages (discussed in the <link
	linkend="packages-using">Packages section</link>), using the
	&man.pkg.delete.1; command:</para>

      <screen>&prompt.root; <userinput>pkg_delete lsof-4.57</userinput></screen>

    </sect2>

    <sect2 id="ports-upgrading">
      <title>Atualizando Ports</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>upgrading</secondary>
      </indexterm>
      <para>First, list outdated ports that have a newer version available in
	the Ports Collection with the &man.pkg.version.1; command:</para>

      <screen>&prompt.root; <userinput>pkg_version -v</userinput></screen>

      <sect3 id="ports-file-updating">
	<title><filename>/usr/ports/UPDATING</filename></title>

	<para>Once you have updated your Ports Collection, before
	  attempting a port upgrade, you should check
	  <filename>/usr/ports/UPDATING</filename>.  This file
	  describes various issues and additional steps users may
	  encounter and need to perform when updating a port, including
	  such things as file format changes, changes in locations of
	  configuration files, or other such incompatibilities with
	  previous versions.</para>

	<para>If <filename>UPDATING</filename> contradicts something you
	  read here, <filename>UPDATING</filename> takes precedence.</para>
      </sect3>

      <sect3 id="portupgrade">
	<title>Atualizando Ports com o Portupgrade</title>

	<indexterm>
	  <primary>portupgrade</primary>
	</indexterm>

      <para>The <application>portupgrade</application> utility is designed
	to easily upgrade installed ports.  It is available from the <filename
	role="package">ports-mgmt/portupgrade</filename> port.  Install it like
	any other port, using the <command>make <maketarget>install
	clean</maketarget></command> command:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portupgrade</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Scan the list of installed ports with the <command>pkgdb
	-F</command> command and fix all the inconsistencies it reports.  It is
	a good idea to do this regularly, before every upgrade.</para>

      <para>When you run <command>portupgrade -a</command>,
	<application>portupgrade</application> will begin to upgrade all the
	outdated ports installed on your system.  Use the <option>-i</option>
	flag if you want to be asked for confirmation of every individual
	upgrade.</para>

      <screen>&prompt.root; <userinput>portupgrade -ai</userinput></screen>

      <para>If you want to upgrade only a
	certain application, not all available ports, use <command>portupgrade
	<replaceable>pkgname</replaceable></command>.  Include the
	<option>-R</option> flag if <application>portupgrade</application>
	should first upgrade all the ports required by the given
	application.</para>

      <screen>&prompt.root; <userinput>portupgrade -R firefox</userinput></screen>

      <para>To use packages instead of ports for installation, provide
	<option>-P</option> flag.  With this option
	<application>portupgrade</application> searches
	the local directories listed in <envar>PKG_PATH</envar>, or
	fetches packages from remote site if it is not found locally.
	If packages can not be found locally or fetched remotely,
	<application>portupgrade</application> will use ports.
	To avoid using ports, specify <option>-PP</option>.</para>

      <screen>&prompt.root; <userinput>portupgrade -PP gnome2</userinput></screen>

      <para>To just fetch distfiles (or packages, if
	<option>-P</option> is specified) without building or
	installing anything, use <option>-F</option>.
	For further information see &man.portupgrade.1;.</para>
      </sect3>

      <sect3 id="portmaster">
	<title>Atualizando Ports com o Portmaster</title>

	<indexterm>
	  <primary>portmaster</primary>
	</indexterm>

	<para><application>Portmaster</application> is another utility for
	  upgrading installed ports.  <application>Portmaster</application>
	  was designed make use of the tools found in the <quote>base</quote>
	  system (it does not depend upon other ports) and uses the
	  information in <filename class="directory">/var/db/pkg/</filename>
	  to determine which ports to upgrade.  It is available from the
	  <filename role="package">ports-mgmt/portmaster</filename>
	  port:</para>

	<screen>&prompt.root; <userinput>cd <filename class="directory">/usr/ports/ports-mgmt/portmaster</filename></userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para><application>Portmaster</application> groups ports into four
	  categories:</para>

	<itemizedlist>
	  <listitem>
	    <para>Root ports (no dependencies, not depended on)</para>
	    </listitem>
	  <listitem>
	    <para>Trunk ports (no dependencies, are depended on)</para>
	    </listitem>
	  <listitem>
	    <para>Branch ports (have dependencies, are depended on)</para>
	    </listitem>
	  <listitem>
	    <para>Leaf ports (have dependencies, not depended on)</para>
	    </listitem>
	</itemizedlist>

	<para>You can list all the installed ports and search
	  for updates using the <option>-L</option> option:</para>

<screen>&prompt.root; <userinput>portmaster -L</userinput>
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache-2.2.3
        ===>>> New version available: apache-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
</screen>

	<para>All the installed ports can be upgraded using this simple
	  command:</para>

	<screen>&prompt.root; <userinput>portmaster -a</userinput></screen>

	<note><para>By default, <application>Portmaster</application>
	  will make a backup package before deleting the existing port.  If
	  the installation of the new version is successful,
	  <application>Portmaster</application> will delete the backup.
	  Using the <option>-b</option> will instruct
	  <application>Portmaster</application> not to automatically delete
	  the backup.  Adding the <option>-i</option> option will start
	  <application>Portmaster</application> in interactive mode, prompting
	  you before upgrading each port.</para></note>

	<para>If you encounter errors during the upgrade process, you can use
	  the <option>-f</option> option to upgrade/rebuild all ports:</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>You can also use <application>Portmaster</application> to
	  install new ports on the system, upgrading all dependencies
	  before building and installing the new port:</para>

	<screen>&prompt.root; <userinput>portmaster <replaceable>shells/bash</replaceable></userinput></screen>

	<para>Please see &man.portmaster.8; for more information.</para>
      </sect3>
    </sect2>

    <sect2 id="ports-disk-space">
      <title>Ports e Espaço em Disco</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>disk-space</secondary>
      </indexterm>
      <para>Using the Ports Collection will use up disk
	space over time.  After building and installing software from the
	ports, you should always remember to clean up
	the temporary <filename class="directory">work</filename> directories
	using the <command>make	<maketarget>clean</maketarget></command>
	command.  You can sweep the whole Ports Collection with the following
	command:</para>

      <screen>&prompt.root; <userinput>portsclean -C</userinput></screen>

      <para>You will accumulate a lot of old source distribution files in the
	<filename class="directory">distfiles</filename> directory over time.
	You can remove them by hand, or you can use the following command to
	delete all the distfiles that are no longer referenced by any
	ports:</para>

      <screen>&prompt.root; <userinput>portsclean -D</userinput></screen>

      <para>Or to remove all distfiles not referenced by any port
	currently installed on your system:</para>

      <screen>&prompt.root; <userinput>portsclean -DD</userinput></screen>

      <note>
	<para>The <command>portsclean</command> utility is part of the
	  <application>portupgrade</application> suite.</para>
      </note>

      <para>Do not forget to remove the installed ports once you no longer need
	them.  A nice tool to help automate this task is available from the
	<filename role="package">ports-mgmt/pkg_cutleaves</filename>
	port.</para>
    </sect2>

  </sect1>

  <sect1 id="ports-nextsteps">
    <title>Atividades Pós-instalação</title>

    <para>After installing a new application you will normally want to
      read any documentation it may have included, edit any
      configuration files that are required, ensure that the
      application starts at boot time (if it is a daemon), and so
      on.</para>

    <para>The exact steps you need to take to configure each
      application will obviously be different.  However, if you have
      just installed a new application and are wondering <quote>What
      now?</quote> these tips might help:</para>

    <itemizedlist>
      <listitem>
	<para>Use &man.pkg.info.1; to find out which files were installed,
	  and where.  For example, if you have just
	  installed FooPackage version 1.0.0, then this command</para>

	<screen>&prompt.root; <userinput>pkg_info -L foopackage-1.0.0 | less</userinput></screen>

	<para>will show all the files installed by the package.  Pay
	  special attention to files in <filename>man/</filename>
	  directories, which will be manual pages,
	  <filename>etc/</filename> directories, which will be
	  configuration files, and <filename>doc/</filename>, which
	  will be more comprehensive documentation.</para>

	<para>If you are not sure which version of the application was
	  just installed, a command like this</para>

	<screen>&prompt.root; <userinput>pkg_info | grep -i <replaceable>foopackage</replaceable></userinput></screen>

	<para>will find all the installed packages that have
	  <replaceable>foopackage</replaceable> in the package name.
	  Replace <replaceable>foopackage</replaceable> in your
	  command line as necessary.</para>
      </listitem>

      <listitem>
	<para>Once you have identified where the application's manual
	  pages have been installed, review them using &man.man.1;.
	  Similarly, look over the sample configuration files, and any
	  additional documentation that may have been provided.</para>
      </listitem>

      <listitem>
	<para>If the application has a web site, check it for
	  additional documentation, frequently asked questions, and so
	  forth.  If you are not sure of the web site address it may
	  be listed in the output from</para>

	<screen>&prompt.root; <userinput>pkg_info <replaceable>foopackage-1.0.0</replaceable></userinput></screen>

	<para>A <literal>WWW:</literal> line, if present, should provide a URL
	  for the application's web site.</para>
      </listitem>

      <listitem>
	<para>Ports que executem processos na inicialização do 
	  sistema (tais como daemons provedores de serviços de Internet) 
	  irão, provavelmente, instalar um script no diretório 
	  <filename>/usr/local/etc/rc.d</filename>. Você poderia 
	  avaliar o conteúdo desse script, realizar alguma correção
	  ou renomeá-lo se necessário. Veja <link 
	  linkend="configtuning-starting-services">Iniciando Serviços</link> 
	  para obter mais informações.</para>
    </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-broken">
    <title>Lidando com Ports Quebrados</title>

      <para>Se você se deparar com um port que não funcione,
        existem algumas coisas que você pode fazer. Elas incluem:</para>

      <orderedlist>
	<listitem>
	  <para>Descubra se há uma correção pendente para o port no
	   <ulink url="&url.base;/support.html#gnats">Banco de Dados de 
	   Problemas Reportados</ulink>. Se assim for, você pode usar a 
	   correção proposta.</para>
	</listitem>

	<listitem>
	  <para>Pergunte ao mantenedor do port se ele pode lhe ajudar. Utilize
	    <command>make <maketarget>mantenedor</maketarget></command> ou consulte
	    o <filename>Makefile</filename> para encontrar o endereço de e-mail 
	    do mantenedor. Lembre-se de incluir o nome, a versão do port (envie a 
	    linha do <filename>Makefile</filename> contendo 
	    <literal>&dollar;&os;:</literal>) e a saída que conduz ao erro quando 
	    você enviar um e-mail ao mantenedor solicitando ajuda.</para>

	  <note>
	    <para>Alguns ports não são mantidos por um únido indivíduo, mas
	      por uma <ulink url="&url.articles.mailing-list-faq;/article.html">lista 
	      de discussão</ulink>. Muitos, mas não todos, destes endereços 
	      assemelham-se com <email role="nolink">freebsd-nomedalista@FreeBSD.org</email>.
	      Por favor, leve isso em consideração quando estiver formulando suas 
	      palavras e perguntas.</para>

	    <para>Em casos particulares, ports que apontam o e-mail
	      <email role="nolink">ports@FreeBSD.org</email> como mantenedor são,
	      na verdade, órfãos. Não existem mantenedores para esses ports. 
	      Correções e suporte, caso existam, vêm da comunidade em geral que 
	      está presente nas listas de discussão. Mais voluntários são sempre 
	      necessários e muito bem-vindos!</para>
	  </note>

	  <para>Se você não obtiver uma resposta, você pode usar o comando 
	    &man.send-pr.1; para enviar um relatório de problemas (veja o artigo 
	    <ulink url="&url.articles.problem-reports;/article.html">Escrevendo 
	    Relatórios de Problemas para FreeBSD</ulink>).</para>
	</listitem>

        <listitem>
	  <para>Corrija você mesmo! O 
	    <ulink url="&url.books.porters-handbook;/index.html">Manual para 
	    Mantenedores de Ports</ulink> inclui informações detalhadas sobre a 
	    infraestrutura dos <quote>Ports</quote> para que você possa corrigir o
	    port quebrado ou até mesmo enviar seu próprio port!</para>
	</listitem>

	<listitem>
	  <para>Obtenha o pacote de um sítio FTP perto de você. A coleção 
	  <quote>primária</quote> está em <hostid role="fqdn">ftp.FreeBSD.org</hostid> 
	    e está localizada no <ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages">
	    diretório de pacotes</ulink>, mas não deixe de conferir o sítio mais próximo na 
	    página de <link linkend="mirrors-ftp">Servidores Espelho</link> 
	    <emphasis>antes</emphasis> de obter o pacote! Estes pacotes são mais propensos a 
	    funcionar, melhor do que você tentar compilar a partir do código fonte e o 
	    processo de instalação é mais agilizado. Use o &man.pkg.add.1; para instalar 
	    o pacote em seu sistema.</para>
	</listitem>
      </orderedlist>
  </sect1>

</chapter>

