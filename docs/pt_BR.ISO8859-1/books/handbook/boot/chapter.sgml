<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!--
  The FreeBSD Documentation Project
  The FreeBSD Brazilian Portuguese Documentation Project

  Original revision: r39544

  $FreeBSD$
-->

<chapter id="boot">
  <title>O Processo de Inicialização do FreeBSD</title>

  <sect1 id="boot-synopsis">
    <title>Sinopse</title>
    <indexterm><primary>booting</primary></indexterm>
    <indexterm><primary>bootstrap</primary></indexterm>

    <para>O processo de iniciar um computador e seu sistema
      operacional é referido como <quote>o processo de
      inicialização</quote>, ou simplesmente
      <quote>inicialização</quote>.  O processo de inicialização do
      FreeBSD oferece uma grande flexibilidade na personalização do
      que acontece quando você inicia o sistema, permitindo você
      selecionar diferentes sistemas operacionais instalados no mesmo
      computador, ou mesmo versões diferentes do mesmo sistema
      operacional ou kernel instalado.</para>

    <para>Este capítulo detalha as opções de configurações que você
      pode configurar e como personalizar o processo de inicialização
      do FreeBSD.  Isso inclui tudo o que acontece até que o kernel do
      FreeBSD tenha iniciado, procurado por dispositivos e iniciado o
      &man.init.8;.  Se você não tem certeza de quando isso acontece,
      isso ocorre quando a cor do texto muda de branco brilhante para
      cinza.</para>

    <para>Depois de ler este capítulo, você saberá:</para>

    <itemizedlist>
      <listitem>
	<para>O que são os componentes de inicialização do FreeBSD, e
	  como eles interagem.</para>
      </listitem>

      <listitem>
	<para>As opções que você pode passar para os componentes na
	  inicialização do FreeBSD para controlar o processo.</para>
      </listitem>

      <listitem>
	<para>Os princípios do &man.device.hints.5;.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>Apenas para x86</title>

      <para>Este capítulo descreve apenas o processo de inicialização
	do FreeBSD rodando em sistemas x86 da Intel.</para>
    </note>
  </sect1>

  <sect1 id="boot-introduction">
    <title>O problema da inicialização</title>

    <para>Ligar o computador e iniciar o sistema operacional possui um
      dilema interessante.  Por definição, o computador não sabe como
      fazer nada até que o sistema operacional tenha iniciado.  Isso
      inclui executar programas que estão no disco rígido.  Então, se
      o computador não pode executar um programa que está no disco
      rígido sem o sistema operacional estar em execução, e o sistema
      operacional está no disco rígido, como o sistema operacional é
      iniciado?</para>

<!-- Este 'para' esta realmente muito ruim.
       Gostaria de opiniões nele -->
    <para>Esse problema é similar ao problema no livro <citetitle>As
      aventuras do Barão Munchausen</citetitle>.  Um personagem caiu
      no fundo de um poço de inspeção, e puxou a si mesmo para fora
      agarrando suas botas, e se içando.  Nos primórdios da
      computação o termo <firstterm>bootstrap</firstterm> (em inglês)
      foi empregado para o mecanismo usado para carregar o sistema
      operacional, e então o termo foi encurtado para
      <quote>boot</quote> (em inglês).</para>

    <indexterm><primary>BIOS</primary></indexterm>

    <indexterm><primary>Basic Input/Output
	System</primary><see>BIOS</see></indexterm>

    <para>Em hardware x86 o sistema básico de entrada e saída (BIOS,
      sigla em inglês) é responsável por iniciar o sistema
      operacional.  Para fazer isso, o BIOS procura no disco rígido
      pelo Registro Mestre de Inicialização (MBR, sigla em inglês),
      que deve estar localizado em um lugar específico do disco
      rígido.  O BIOS tem conhecimento suficiente do hardware para
      obter e executar o MBR, e assume que o MBR pode se encarregar
      das tarefas restantes necessárias para iniciar o sistema
      operacional, possivelmente com a ajuda do BIOS.</para>

    <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <indexterm><primary>Boot Loader</primary></indexterm>

<!-- Gostaria de deixar mais claro a diferença entre boot manager e
boot loader -->
    <para>O código dentro do MBR é normalmente referido por
      <emphasis>gerenciador de inicialização</emphasis>, especialmente
      quando ele interage com o usuário.  Geralmente nesse caso o
      gerenciador de inicialização possui mais código na primeira
      <emphasis>trilha</emphasis> do disco rígido ou dentro de algum
      sistema de arquivos do sistema operacional.  (Um gerenciador de
      inicialização é chamado algumas vezes de <emphasis>carregador de
      inicialização</emphasis>, entretanto o FreeBSD usa este termo
      para um estágio posterior da inicialização.) Os gerenciadores de
      inicialização mais populares são
      <application>boot0</application> (também conhecido como
      <application>Boot Easy</application>, o gerenciador de
      inicialização padrão do &os;), <application>Grub</application>,
      <application>GAG</application>, e
      <application>LILO</application>.  (Somente o
      <application>boot0</application> cabe no MBR.)</para>

    <para>Se você tem apenas um sistema operacional instalado nos seus
      discos rígidos então um MBR padrão será suficiente.  Esse MBR
      procura pela primeira divisão inicializável (ou seja, ativa) do
      disco rígido, e então executa o código nessa divisão para
      carregar o restante do sistema operacional.  O MBR instalado
      pelo &man.fdisk.8;, é um MBR padrão.  Ele é baseado no
      <filename>/boot/mbr</filename>.</para>

    <para>Se você tem instalado vários sistemas operacionais nos seus
      discos rígidos então você pode instalar um gerenciador de
      inicialização, que pode exibir uma lista dos sistemas
      operacionais, e permitir que você escolha um para iniciar.  Dois
      destes são discutidos na próxima subseção.</para>

    <para>O restante da inicialização do FreeBSD é dividido em três
      etapas.  A primeira etapa é executada pelo MBR, que sabe apenas
      o suficiente para deixar o computador em um estado específico e
      executar a segunda etapa.  A segunda etapa pode fazer um pouco
      mais, antes de executar a terceira etapa.  A terceira etapa
      finaliza a tarefa de carregar o sistema operacional.  O trabalho
      é dividido nestas três etapas porque o padrão do PC coloca
      limites no tamanho do programa que pode ser executado nas etapas
      um e dois.  Dividindo as tarefas em etapas permite que o FreeBSD
      tenha um inicializador mais flexível.</para>

    <indexterm><primary>kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>O kernel é então iniciado e começa a procurar por
      dispositivos e inicializá-los para uso.  Uma vez que o processo
      de inicialização do kernel termina, o kernel passa o controle
      para o processo do usuário &man.init.8;, que então verifica se
      os discos estão em um estado utilizável.  Em seguida o
      &man.init.8; inicia a configuração de recursos no nível do
      usuário que monta sistemas de arquivos, inicia placas de rede
      para se comunicar na rede, e geralmente inicia todos os
      processos que normalmente são executados na inicialização de um
      sistema FreeBSD.</para>
  </sect1>

  <sect1 id="boot-blocks">
    <title>O Gerenciador de Inicialização e As Etapas da
      Inicialização</title>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <sect2 id="boot-boot0">
      <title>O Gerenciador de Inicialização</title>
      <indexterm><primary>Master Boot Record
	  (MBR)</primary></indexterm>

      <para>O código no MBR ou o gerenciador de inicialização é
	referido algumas vezes como a <emphasis>etapa zero</emphasis> do
	processo de inicialização.  Essa subseção discute dois dos
	gerenciadores de inicialização mencionados anteriormente:
	<application>boot0</application> e
	<application>LILO</application>.</para>

      <formalpara>
	<title>O Gerenciador de Inicialização
	<application>boot0</application>:</title>

	<para>O MBR instalado pelo instalador do FreeBSD ou seja o
	  &man.boot0cfg.8;, por padrão, é baseado no
	  <filename>/boot/boot0</filename>.  (O programa
	  <application>boot0</application> é muito simples, pois o
	  programa no <abbrev>MBR</abbrev> pode ter apenas 446 bytes
	  de tamanho devido à tabela de divisão do disco rígido e ao
	  identificador <literal>0x55AA</literal> que existe no fim do
	  MBR.) Se você instalou o <application>boot0</application> e
	  possui vários sistemas operacionais nos seus discos rígidos,
	  então você verá algo parecido com a tela abaixo no momento
	  da inicialização:</para>
      </formalpara>

      <example id="boot-boot0-example">
	<title>Imagem de tela do <filename>boot0</filename></title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>É conhecido que outros sistemas operacionais, em
	particular o &windows;, sobrescrevem o MBR.  Se isso
	acontecer, ou se você quiser substituir o MBR existente pelo o
	MBR do FreeBSD então use o seguinte comando:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>dispositivo</replaceable></userinput></screen>

      <para>Onde <replaceable>dispositivo</replaceable> é o
	dispositivo do qual você inicializa o seu computador, tal como
	<devicename>ad0</devicename> para o primeiro disco rígido IDE,
	<devicename>ad2</devicename> para o primeiro disco rígido na
	segunda controladora IDE, <devicename>da0</devicename> para o
	primeiro disco rígido SCSI, e assim por diante.  Ou, se você
	preferir uma configuração personalizada do MBR, use
	&man.boot0cfg.8;.</para>

      <formalpara>
	<title>O Gerenciador de Inicialização LILO:</title>

	<para>Para que esse gerenciador de inicialização possa iniciar
	  o FreeBSD, primeiro inicie o Linux e adicione a seguinte
	  configuração no arquivo
	  <filename>/etc/lilo.conf</filename>:</para>
      </formalpara>

      <programlisting>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Na configuração acima, especifique a partição primária do
	FreeBSD usando as especificações do Linux, substituindo
	<replaceable>X</replaceable> pela letra que representa o disco
	rígido no Linux e <replaceable>Y</replaceable> pelo número que
	representa a partição primária no Linux.  Se você está usando
	um disco rígido <acronym>SCSI</acronym>, você precisará mudar
	<replaceable>/dev/hd</replaceable> por algo parecido com
	<replaceable>/dev/sd</replaceable>.  A linha
	<option>loader=/boot/chain.b</option> pode ser omitida caso
	você tenha os dois sistemas operacionais no mesmo disco
	rígido.  Agora execute o comando
	<command>/sbin/lilo&nbsp;-v</command> para gravar suas
	mudanças no sistema; você deve verificar isso checando as
	mensagens na tela.</para>
    </sect2>

    <sect2 id="boot-boot1">
      <title>Primeira Etapa, <filename>/boot/boot1</filename>, e
	Segunda Etapa, <filename>/boot/boot2</filename></title>

      <para>No conceito a primeira e segunda etapa são partes do mesmo
	programa, na mesma área do disco rígido.  Essa divisão é
	devida a limitações de espaço, mas você sempre deve
	instalá-las juntas.  As duas etapas são copiadas do arquivo
	combinado <filename>/boot/boot</filename> pelo instalador ou
	<application>bsdlabel</application> (veja abaixo).</para>

      <para>Elas ficam armazenadas fora do sistema de arquivos, na
	primeira trilha da divisão de inicialização do disco rígido, a
	partir do primeiro setor.  Esse é o local onde o <link
	linkend="boot-boot0">boot0</link>, ou qualquer outro
	gerenciador de boot, espera encontrar o programa que será
	executado para continuar o processo de inicialização.  O
	número de setores usados é facilmente determinado pelo tamanho
	do <filename>/boot/boot</filename>.</para>

      <para>O <filename>boot1</filename> é muito simples, pois ele
	pode ter apenas o tamanho de 512 bytes, e ele conhece o
	suficiente sobre o <firstterm>bsdlabel</firstterm> do FreeBSD,
	o qual tem informações sobre a divisão do disco rígido, para
	encontrar e executar o <filename>boot2</filename>.</para>

      <para>O <filename>boot2</filename> é ligeiramente mais
	 sofisticado, e conhece o sistema de arquivos do FreeBSD o
	 suficiente para encontrar arquivos, e pode fornecer uma
	 interface simples para escolher o arquivo do kernel para
	 carregar e executar.</para>

      <para>O <link linkend="boot-loader">carregador</link> é muito
	mais sofisticado, e fornece uma configuração de inicialização
	fácil de usar, o <filename>boot2</filename> executa o
	carregador, mas anteriormente ele era encarregado de executar
	o kernel diretamente.</para>

      <example id="boot-boot2-example">
	<title>Imagem de tela do <filename>boot2</filename></title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>Se você precisar substituir o <filename>boot1</filename> e
	o <filename>boot2</filename> use o &man.bsdlabel.8;:</para>

      <screen>&prompt.root; <userinput>bsdlabel -B <replaceable>discodivisão</replaceable></userinput></screen>

      <para>Onde <replaceable>discodivisão</replaceable> é o disco
	rígido e a divisão da qual você quer iniciar, tal como
	<devicename>ad0s1</devicename> para a primeira divisão no
	primeiro disco rígido IDE.</para>

      <warning>
	<title>Modo Dedicado Arriscado:</title>

	<para>Se você usar apenas o nome do disco rígido, tal como
	  <devicename>ad0</devicename>, no comando
	  &man.bsdlabel.8; você irá criar um disco dedicado, sem
	  divisões do disco rígido. É quase certo que não é isso que
	  você quer fazer, então tenha certeza que você verificou o
	  comando &man.bsdlabel.8; antes de apertar Enter.</para>
      </warning>
    </sect2>

    <sect2 id="boot-loader">
      <title>Etapa Três, <filename>/boot/loader</filename></title>

      <indexterm><primary>boot-loader</primary></indexterm>

      <para>O carregador é a etapa final das três etapas da 
        inicialização, está localizado no sistema de arquivos,
	geralmente como <filename>/boot/loader</filename>.</para>

      <para>O carregador é usado como um método amigável para
        configuração, usando um conjunto de comandos próprios fáceis
        de usar, apoiado por um interpretador mais poderoso, com um
        conjunto de comandos mais complexos.</para>

      <sect3 id="boot-loader-flow">
	<title>Fluxo do Programa Carregador</title>

	<para>Durante a inicialização, o carregador irá procurar por
	  um console e por discos, e descobrir a partir de qual disco
	  ele está iniciando.  Ele definirá variáveis necessárias, e
	  um interpretador será iniciado por onde comandos do usuário
	  podem ser passados de um script ou interativamente.</para>

	<indexterm><primary>loader</primary></indexterm>
	<indexterm><primary>loader configuration</primary></indexterm>

	<para>O carregador irá ler o
	  <filename>/boot/loader.rc</filename>, que por padrão lê o
	  <filename>/boot/defaults/loader.conf</filename> que define
	  valores padrões para variáveis e então lê o
	  <filename>/boot/loader.conf</filename> para definições do
	  usuário para essas variáveis. O
	  <filename>loader.rc</filename> então age conforme essas
	  variáveis, carregando os módulos e o kernel que foram
	  selecionados.</para>

	<para>Finalmente, por padrão, o carregador espera por 10
	  segundos para uma tecla ser pressionada, após isso inicia o
	  kernel.  Se interrompido, será exibido para o usuário um
	  prompt que entende um conjunto de comandos de uso fácil,
	  onde o usuário pode ajustar variáveis, descarregar todos os
	  módulos, carregar módulos, e então finalmente iniciar ou
	  reiniciar.</para>
      </sect3>

      <sect3 id="boot-loader-commands">
	<title>Comandos Internos do Carregador</title>

	<para>Estes são os comandos mais comuns usados no carregador.
	  Para uma explicação completa de todos os comandos
	  disponíveis, por favor olhe o &man.loader.8;.</para>

	<variablelist>
	  <varlistentry>
	    <term>autoboot <replaceable>segundos</replaceable></term>

	    <listitem>
	      <para>Prossegue com a inicialização do kernel se não for
		interrompido no tempo especificado, em segundos.
		Exibe uma contagem regressiva, o valor padrão é 10
		segundos.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>boot
	      <optional><replaceable>-opções</replaceable></optional>
	      <optional><replaceable>nomedokernel</replaceable></optional></term>

	    <listitem>
	      <para>Prossegue imediatamente com a inicialização do
		kernel, com as opções especificadas, se existir
		alguma, e com o nome do kernel especificado, se for
		especificado.  Somente é possível especificar o nome
		do kernel no prompt depois que o comando
		<emphasis>unload</emphasis> for usado, senão o kernel
		carregado anteriormente será usado.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>boot-conf</term>

	    <listitem>
	      <para>Passa pela mesma configuração automática dos
		módulos baseando-se nas variáveis do mesmo modo que
		acontece na inicialização.  Isso somente faz sentido
		se você primeiramente usar o comando
		<command>unload</command>, e mudar algumas variáveis,
		mais comumente o <envar>kernel</envar>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>help
	      <optional><replaceable>tópico</replaceable></optional></term>

	    <listitem>
	      <para>Exibe texto de ajuda contido no
		<filename>/boot/loader.help</filename>.  Se o tópico
		for <literal>index</literal>, então a lista de tópicos
		disponíveis é exibida.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>include <replaceable>arquivo</replaceable>
	      &hellip;</term>

	    <listitem>
	      <para>Processa o arquivo com o nome dado.  O arquivo é
		lido, e interpretado linha por linha.  Quando um erro
		é encontrado, o comando para imediatamente.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>load <optional><option>-t</option>
	      <replaceable>tipo</replaceable></optional>
	      <replaceable>arquivo</replaceable></term>

	    <listitem>
	      <para>Carrega o kernel, módulo do kernel, ou arquivo do
		tipo e nome especificado.  Qualquer argumento
		após o nome do arquivo é passado para o
		arquivo.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>ls <optional><option>-l</option></optional>
	      <optional><replaceable>caminho</replaceable></optional></term>

	    <listitem>
	      <para>Exibe uma lista de arquivos no caminho
		especificado, ou do diretório raiz, se um caminho não
		for especificado.  Se <option>-l</option> é
		especificada, o tamanho dos arquivos é exibido
		também.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>lsdev
	      <optional><option>-v</option></optional></term>

	    <listitem>
	      <para>Lista todos os dispositivos dos quais pode ser
		possível carregar módulos.  Se <option>-v</option> é
		especificada, mais detalhes são exibidos.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>lsmod
	      <optional><option>-v</option></optional></term>

	    <listitem>
	      <para>Exibe os módulos carregados.  Se
		<option>-v</option> é especificada, mais detalhes são
		exibidos.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>more <replaceable>arquivo</replaceable></term>

	    <listitem>
	      <para>Exibe o arquivo especificado, com uma pausa a cada
		 <varname>LINES</varname> linhas exibidas.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>reboot</term>

	    <listitem>
	      <para>Reinicia imediatamente o sistema.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>set <replaceable>variável</replaceable></term>
	    <term>set
	      <replaceable>variável</replaceable>=<replaceable>valor</replaceable></term>

	    <listitem>
	      <para>Define os valores das variáveis de ambiente.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>unload</term>

	    <listitem>
	      <para>Remove todos os módulos carregados.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 id="boot-loader-examples">
	<title>Exemplos do Carregador</title>

	<para>Aqui tem alguns exemplos de uso do carregador na
	  prática:</para>

	<itemizedlist>
	  <indexterm><primary>single-user mode</primary></indexterm>

	  <listitem>
	    <para>Para iniciar seu kernel habitual, mas em modo
	      mono-usuário:</para>

	    <screen><userinput>boot -s</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Para descarregar o seu kernel habitual e os módulos,
	      e então carregar o seu kernel antigo (ou qualquer
	      outro):</para>

	    <indexterm>
	      <primary><filename>kernel.old</filename></primary>
	    </indexterm>

	    <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	    <para>Você pode usar <filename>kernel.GENERIC</filename>
	      para se referir ao kernel genérico que vem com o disco
	      de instalação, ou <filename>kernel.old</filename> para
	      se referir ao seu kernel anterior (isto é, quando você
	      atualizou ou configurou o seu próprio kernel).</para>

	    <note>
	      <para>Use o seguinte para carregar seus módulos
		habituais com outro kernel:</para>

	      <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen></note>
	  </listitem>

	  <listitem>
	    <para>Para carregar um script de configuração do kernel
	      (um script automatizado para fazer o que você
	      normalmente faria no configurador de
	      inicialização):</para>

	    <screen><userinput>load -t userconfig_script <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 id="boot-splash">
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Joseph J.</firstname>
	      <surname>Barbish</surname>
	      <contrib>Contributed by </contrib>
	    </author>
	  </authorgroup>
	</sect3info>

	<title>Telas de Abertura da Inicialização</title>

	<para>A tela de abertura cria uma tela de inicialização mais
	  atraente em comparação com as mensagens de inicialização
	  originais.  Essa tela será exibida até que o console ou um
	  gerenciador gráfico exiba um prompt de login.</para>

	<para>Existem dois ambientes básicos disponíveis no &os;.  O
	  primeiro é o ambiente de linha de comando legado do console
	  virtual padrão.  Depois que o sistema termina de iniciar, um
	  prompt de login é exibido no console.  O segundo ambiente é
	  o ambiente de trabalho gráfico X11.  Depois que o <link
	  linkend="x-install">X11</link> e um dos ambientes gráficos,
	  como <application>GNOME</application>,
	  <application>KDE</application>, ou
	  <application>XFce</application> forem instalados, o ambiente
	  gráfico X11 pode ser iniciado usando o comando
	  <command>startx</command>.</para>

	<para>Alguns usuários preferem a tela de login gráfica X11 do
	  que o tradicional prompt de login no modo texto.
	  Gerenciadores gráficos como <application>XDM</application>
	  para o &xorg;, <application>gdm</application> para o
	  <application>GNOME</application>, e
	  <application>kdm</application> para o
	  <application>KDE</application> (e qualquer um outro da
	  coleção do Ports) fornecem uma tela de login gráfico no
	  lugar do prompt de login no console.  Após um login bem
	  sucedido, eles apresentam ao usuário um
	  <foreignphrase>desktop</foreignphrase> gráfico.</para>

	<para>No ambiente de linha de comando, a tela de abertura
	  deveria esconder todas as mensagens do processo de
	  inicialização e das tarefas de inicialização antes de exibir
	  o prompt de login.  No ambiente X11, os usuários podem
	  visualizar uma inicialização mais limpa semelhante a algo
	  mais próximo que um usuário do &microsoft; &windows; ou de
	  um sistema não-unix poderia ter.</para>

	<sect4 id="boot-splash-function">
	  <title>Função da Tela de Abertura</title>

	  <para>A função da tela de abertura suporta arquivos de
	    imagens bitmap de 256 cores (<filename>.bmp</filename>),
	    ZSoft <acronym>PCX</acronym> (<filename>.pcx</filename>),
	    ou TheDraw (<filename>.bin</filename>).  Além disso, o
	    arquivo da imagem de abertura deve ter uma resolução de
	    320 por 200 pixels ou menos para funcionar nos adaptadores
	    de vídeo VGA padrão.</para>
	
	  <para>Para usar imagens maiores, até do tamanho máximo de
	    resolução de 1024 por 768 pixels, ative o suporte
	    <acronym>VESA</acronym> incluído no &os;.  Isso pode ser
	    habilitado por carregar o módulo <acronym>VESA</acronym>
	    durante a inicialização do sistema, ou por adicionar a
	    opção <literal>VESA</literal> na configuração do kernel e
	    compilar um kernel customizado (veja <xref
	    linkend="kernelconfig"/>).  O suporte ao
	    <acronym>VESA</acronym> dá ao usuário a capacidade de
	    exibir uma imagem de abertura que preenche toda a
	    tela.</para>

	  <para>Enquanto a tela de abertura está sendo exibida durante
	    o processo de inicialização, ela pode ser desligada a
	    qualquer momento pressionando qualquer tecla do
	    teclado.</para>

	  <para>A tela de abertura também é por padrão um protetor de
	    tela quando fora do ambiente gráfico.  Depois de um
	    período de tempo sem usar o computador a tela irá mudar
	    para a tela de abertura e percorrer passos mudando a
	    intensidade da imagem, de brilhante para muito escuro e
	    começando novamente.  Esse comportamento padrão da tela de
	    abertura (protetor de tela) pode ser sobrescrito
	    adicionando a linha <literal>saver=</literal> no arquivo
	    <filename>/etc/rc.conf</filename>.  A opção
	    <literal>saver=</literal> tem vários protetores de telas
	    embutidos para escolher, a lista completa pode ser
	    encontrada na página do manual &man.splash.4;.  Note que a
	    opção <literal>saver=</literal> especificada no arquivo
	    <filename>/etc/rc.conf</filename> somente se aplica nos
	    consoles virtuais.  Ela não tem efeito nos gerenciadores
	    gráficos X11.</para>

	  <para>Algumas mensagens de inicialização, incluindo o menu
	    de opções e o contador de tempo de espera são exibidas
	    durante a inicialização, mesmo quando a tela de abertura
	    está habilitada.</para>

	  <para>Arquivos de exemplo de tela de abertura podem ser
	    baixados da galeria em <ulink
	    url="http://artwork.freebsdgr.org/node/3/">http://artwork.freebsdgr.org</ulink>.
	    Ao instalar o port <filename
	    role="package">sysutils/bsd-splash-changer</filename>,
	    imagens aleatórias podem ser escolhidas a cada
	    inicialização a partir de uma coleção de imagens.</para>
	</sect4>

	<sect4 id="boot-splash-enable">
	  <title>Habilitando a Função de Tela de Abertura</title>

	  <para>O arquivo da tela de abertura
	    (<filename>.bmp</filename>, <filename>.pcx</filename>, ou
	    <filename>.bin</filename>) tem que ser colocado na
	    partição raiz, por exemplo no diretório <filename
	    class="directory">/boot</filename>.</para>

	  <para>Para a resolução padrão da inicialização (256 cores,
	    320 por 200 pixels, ou menos), edite o
	    <filename>/boot/loader.conf</filename>, para conter o
	    seguinte:</para>

	  <programlisting>splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

	  <para>Para resoluções de vídeo maiores até o máximo de 1024
	    por 768 pixels, edite o
	    <filename>/boot/loader.conf</filename>, para conter o
	    seguinte:</para>

	  <programlisting>vesa_load="YES"
splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

	  <para>As linhas acima assumem que o
	    <filename><replaceable>/boot/splash.bmp</replaceable></filename>
	    é usado para tela de abertura.  Quando um arquivo
	    <acronym>PCX</acronym> for desejado, use a seguinte
	    configuração, adicionando a linha
	    <literal>vesa_load="YES"</literal> dependendo da
	    resolução.</para>

	  <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.pcx</replaceable>"</programlisting>

	  <para>Na versão 8.3 há uma outra opção para usar arte ascii
	    no formato <ulink
	    url="https://en.wikipedia.org/wiki/TheDraw">TheDraw</ulink>.</para>

	  <programlisting>splash_txt="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bin</replaceable>"</programlisting>

	  <para>O nome do arquivo não está restrito a
	    <quote>splash</quote> como mostrado no exemplo acima.  Ele
	    pode ser qualquer coisa desde que seja um dos tipos
	    referidos acima tal como,
	    <filename><replaceable>splash_640x400</replaceable>.bmp</filename>
	    ou
	    <filename><replaceable>bluewave</replaceable>.pcx</filename>.</para>

	  <para>Algumas outras opções interessantes do
	  <filename>loader.conf</filename>:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>beastie_disable="YES"</literal></term>

	      <listitem>
		<para>Isso fará com que o menu de opções da
		  inicialização não seja exibido, mas a contagem
		  regressiva estará presente.  Mesmo com a exibição do
		  menu desativada, digitando uma opção de seleção
		  durante a contagem regressiva irá executar a opção
		  correspondente.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>loader_logo="beastie"</literal></term>

	      <listitem>
		<para>Isso irá substituir as palavras padrões
		  <quote>&os;</quote>, que são exibidas na direita do
		  menu de inicialização por uma logo colorida do
		  beastie como havia em versões passadas.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Para mais informações, por favor veja as páginas do
	    manual &man.splash.4;, &man.loader.conf.5;, e
	    &man.vga.4;.</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>Kernel Interaction During Boot</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>boot interaction</secondary>
    </indexterm>

    <para>Once the kernel is loaded by either <link
	linkend="boot-loader">loader</link> (as usual) or <link
	linkend="boot-boot1">boot2</link> (bypassing the loader), it
      examines its boot flags, if any, and adjusts its behavior as
      necessary.</para>

    <sect2 id="boot-kernel-bootflags">
      <title>Kernel Boot Flags</title>

      <indexterm>
	<primary>kernel</primary>
	<secondary>bootflags</secondary>
      </indexterm>

      <para>Here are the more common boot flags:</para>

      <variablelist id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>during kernel initialization, ask for the device
	      to mount as the root file system.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>boot from CDROM.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>run UserConfig, the boot-time kernel
	      configurator</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>boot into single-user mode</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>be more verbose during kernel startup</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>There are other boot flags, read &man.boot.8; for more
	  information on them.</para>
      </note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: the Boot-time Kernel Configurator</title>

      <para></para>
    </sect2> -->
  </sect1>

  <sect1 id="device-hints">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 18 OCT 2002 -->
    </sect1info>

    <title>Device Hints</title>

    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <para>During initial system startup, the boot &man.loader.8; will
      read the &man.device.hints.5; file.  This file stores kernel
      boot information known as variables, sometimes referred to as
      <quote>device hints</quote>.  These <quote>device hints</quote>
      are used by device drivers for device configuration.</para>

    <para>Device hints may also be specified at the
      <link linkend="boot-loader">
      Stage 3 boot loader</link> prompt.  Variables can be added using
      <command>set</command>, removed with <command>unset</command>,
      and viewed with the <command>show</command> commands.  Variables
      set in the <filename>/boot/device.hints</filename> file can be
      overridden here also.  Device hints entered at the boot loader
      are not permanent and will be forgotten on the next
      reboot.</para>

    <para>Once the system is booted, the &man.kenv.1; command can be
      used to dump all of the variables.</para>

    <para>The syntax for the <filename>/boot/device.hints</filename>
      file is one variable per line, using the standard hash
      <quote>#</quote> as comment markers.  Lines are constructed as
      follows:</para>

    <screen><userinput>hint.driver.unit.keyword="<replaceable>value</replaceable>"</userinput></screen>

    <para>The syntax for the Stage 3 boot loader is:</para>

    <screen><userinput>set hint.driver.unit.keyword=<replaceable>value</replaceable></userinput></screen>

    <para><literal>driver</literal> is the device driver name,
      <literal>unit</literal> is the device driver unit number, and
      <literal>keyword</literal> is the hint keyword.  The keyword may
      consist of the following options:</para>

    <itemizedlist>
      <listitem>
	<para><literal>at</literal>: specifies the bus which the
	  device is attached to.</para>
      </listitem>

      <listitem>
	<para><literal>port</literal>: specifies the start address of
	  the <acronym>I/O</acronym> to be used.</para>
      </listitem>

      <listitem>
	<para><literal>irq</literal>: specifies the interrupt request
	  number to be used.</para>
      </listitem>

      <listitem>
	<para><literal>drq</literal>: specifies the DMA channel
	  number.</para>
      </listitem>

      <listitem>
	<para><literal>maddr</literal>: specifies the physical memory
	  address occupied by the device.</para>
      </listitem>

      <listitem>
	<para><literal>flags</literal>: sets various flag bits for the
	  device.</para>
      </listitem>

      <listitem>
	<para><literal>disabled</literal>: if set to
	  <literal>1</literal> the device is disabled.</para>
      </listitem>
    </itemizedlist>

    <para>Device drivers may accept (or require) more hints not listed
      here, viewing their manual page is recommended.  For more
      information, consult the &man.device.hints.5;, &man.kenv.1;,
      &man.loader.conf.5;, and &man.loader.8; manual pages.</para>
  </sect1>

  <sect1 id="boot-init">
    <title>Init: Process Control Initialization</title>

    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>

    <para>Once the kernel has finished booting, it passes control to
      the user process &man.init.8;, which is located at
      <filename>/sbin/init</filename>, or the program path specified
      in the <envar>init_path</envar> variable in
      <command>loader</command>.</para>

    <sect2 id="boot-autoreboot">
      <title>Automatic Reboot Sequence</title>

      <para>The automatic reboot sequence makes sure that the file
	systems available on the system are consistent.  If they are
	not, and &man.fsck.8; cannot fix the inconsistencies,
	&man.init.8; drops the system into
	<link linkend="boot-singleuser">single-user mode</link> for
	the system administrator to take care of the problems
	directly.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>Single-User Mode</title>
      <indexterm><primary>single-user mode</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>

      <para>This mode can be reached through the
	<link linkend="boot-autoreboot">automatic reboot
	  sequence</link>, or by the user booting with the
	<option>-s</option> option or setting the
	<envar>boot_single</envar> variable in
	<command>loader</command>.</para>

      <para>It can also be reached by calling &man.shutdown.8; without
	the reboot (<option>-r</option>) or halt (<option>-h</option>)
	options, from <link linkend="boot-multiuser">multi-user
	  mode</link>.</para>

      <para>If the system <literal>console</literal> is set to
	<literal>insecure</literal> in <filename>/etc/ttys</filename>,
	then the system prompts for the <username>root</username>
	password before initiating single-user mode.</para>

      <example id="boot-insecure-console">
	<title>An Insecure Console in
	  <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
	<para>An <literal>insecure</literal> console means that you
	  consider your physical security to the console to be
	  insecure, and want to make sure only someone who knows the
	  <username>root</username> password may use single-user mode,
	  and it does not mean that you want to run your console
	  insecurely.  Thus, if you want security, choose
	  <literal>insecure</literal>, not
	  <literal>secure</literal>.</para>
      </note>
    </sect2>

    <sect2 id="boot-multiuser">
      <title>Multi-User Mode</title>
      <indexterm><primary>multi-user mode</primary></indexterm>

      <para>If &man.init.8; finds your file systems to be in order, or
	once the user has finished in <link
	  linkend="boot-singleuser">single-user mode</link>, the
	system enters multi-user mode, in which it starts the
	resource configuration of the system.</para>

      <sect3 id="boot-rc">
	<title>Resource Configuration (rc)</title>

	<indexterm><primary>rc files</primary></indexterm>

	<para>The resource configuration system reads in
	  configuration defaults from
	  <filename>/etc/defaults/rc.conf</filename>, and
	  system-specific details from
	  <filename>/etc/rc.conf</filename>, and then proceeds to
	  mount the system file systems mentioned in
	  <filename>/etc/fstab</filename>, start up networking
	  services, start up miscellaneous system daemons, and
	  finally runs the startup scripts of locally installed
	  packages.</para>

	<para>The &man.rc.8; manual page is a good reference to the
	  resource configuration system, as is examining the scripts
	  themselves.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>Shutdown Sequence</title>

    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Upon controlled shutdown, via &man.shutdown.8;,
      &man.init.8; will attempt to run the script
      <filename>/etc/rc.shutdown</filename>, and then proceed to send
      all processes the <literal>TERM</literal> signal, and
      subsequently the <literal>KILL</literal> signal to any that do
      not terminate timely.</para>

    <para>To power down a FreeBSD machine on architectures and systems
      that support power management, use the command
      <command>shutdown -p now</command> to turn the power off
      immediately.  To just reboot a FreeBSD system, just use
      <command>shutdown -r now</command>.  You need to be
      <username>root</username> or a member of
      <groupname>operator</groupname> group to run &man.shutdown.8;.
      The &man.halt.8; and &man.reboot.8; commands can also be used,
      please refer to their manual pages and to &man.shutdown.8;'s one
      for more information.</para>

    <note>
      <para>Power management requires &man.acpi.4; support in the
	kernel or loaded as module for.</para>
    </note>
  </sect1>
</chapter>
